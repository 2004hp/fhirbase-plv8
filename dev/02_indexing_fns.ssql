-- INDEXING FUNCTIONS
-- TOKEN INDEX
-- TODO: create facade fn like date

func jsonb_primitive_to_text(x jsonb) RETURNS text
  SELECT CASE
   WHEN jsonb_typeof(x) = 'null' THEN
     NULL
   ELSE
     json_build_object('x', x)->>'x'
  END

func index_primitive_as_token( content jsonb, path text[]) RETURNS varchar[]
  SELECT
  array_agg(jsonb_primitive_to_text(unnest::jsonb))::varchar[]
  FROM unnest(json_get_in(content, path))

func index_coding_as_token( content jsonb, path text[]) RETURNS varchar[]
  WITH codings AS (
    SELECT unnest as cd
    FROM unnest(json_get_in(content, path))
  )
  SELECT array_agg(x)::varchar[] FROM (
    SELECT cd->>'code' as x
    from codings
    UNION
    SELECT cd->>'system' || '|' || (cd->>'code') as x
    from codings
  ) _

func index_codeableconcept_as_token( content jsonb, path text[]) RETURNS varchar[]
  SELECT index_coding_as_token(content, array_append(path,'coding'))

func index_identifier_as_token(content jsonb, path text[]) RETURNS varchar[]
  WITH idents AS (
    SELECT unnest as cd
    FROM unnest(json_get_in(content, path))
  )
  SELECT array_agg(x)::varchar[] FROM (
    SELECT cd->>'value' as x
    from idents
    UNION
    SELECT cd->>'system' || '|' || (cd->>'value') as x
    from idents
  ) _

func index_as_reference(content jsonb, path text[]) RETURNS varchar[]
  WITH idents AS (
    SELECT unnest as cd
    FROM unnest(json_get_in(content, path))
  )
  SELECT array_agg(x)::varchar[] FROM (
    SELECT cd->>'reference' as x
    from idents
    UNION
    SELECT _last(regexp_split_to_array(cd->>'reference', '\/')) as x
    from idents
  ) _


--TODO: this is KISS implementation
-- the simplest way is to collect only values
-- so we need collect values function
func _unaccent_string(_text text) RETURNS text
  SELECT translate(_text,
    'âãäåāăąÁÂÃÄÅĀĂĄèééêëēĕėęěĒĔĖĘĚìíîïìĩīĭÌÍÎÏÌĨĪĬóôõöōŏőÒÓÔÕÖŌŎŐùúûüũūŭůÙÚÛÜŨŪŬŮ',
    'aaaaaaaAAAAAAAAeeeeeeeeeeEEEEEiiiiiiiiIIIIIIIIoooooooOOOOOOOOuuuuuuuuUUUUUUUU')

func _to_string(_text text) RETURNS text
  SELECT translate(_text,
    '"[]{}\\:,',
    '        ');

func index_as_string( content jsonb, path text[]) RETURNS text
  SELECT
  regexp_replace(
    _to_string(_unaccent_string(json_get_in(content, path)::text))::text,
    E'\\s+', ' ', 'g')

/* vim: ft=sql
*/
