proc _tpl(_tpl_ text, variadic _bindings_ varchar[]) RETURNS text
  --- replace {{var}} in template string
  --- EXAMPLE: _tpl('{{a}}={{b}}', 'a', 'A','b','B') => 'A=B'
  result text := _tpl_;
  BEGIN
    FOR i IN 1..(array_upper(_bindings_, 1)/2) LOOP
      result := replace(result, '{{' || _bindings_[i*2 - 1] || '}}', coalesce(_bindings_[i*2], ''));
    END LOOP;
    RETURN result;

proc! _eval(_str_ text) RETURNS text
  -- eval string
  BEGIN
    EXECUTE _str_;
    RETURN _str_;

func _butlast(_ar_ anyarray) RETURNS anyarray
  --- cut last element of array
  SELECT _ar_[array_lower(_ar_,1) : array_upper(_ar_,1) - 1]

func _is_descedant(_parent_ anyarray, _child_ anyarray) RETURNS boolean
  --- test _parent_ is prefix of _child_
  SELECT _child_[array_lower(_parent_,1) : array_upper(_parent_,1)] = _parent_;

func _subpath(_parent_ anyarray, _child_ anyarray) RETURNS varchar[]
  --- remove _parent_ elements from begining of _child_
  SELECT _child_[array_upper(_parent_,1) + 1 : array_upper(_child_,1)];


func _rest(_ar_ anyarray) RETURNS anyarray
  --- return rest of array
  SELECT _ar_[2 : array_upper(_ar_,1)];

func _last(_ar_ anyarray) RETURNS anyelement
  --- return last element of collection
  SELECT _ar_[array_length(_ar_,1)];

func column_name(name varchar, type varchar) RETURNS varchar
  --- just eat [x] from name
  SELECT replace(name, '[x]', '' || type);

func _is_array(_json jsonb) RETURNS boolean
  SELECT jsonb_typeof(_json) = 'array';

func _is_object(_json jsonb) RETURNS boolean
  SELECT jsonb_typeof(_json) = 'object';

proc json_get_in(json jsonb, path varchar[]) RETURNS jsonb[]
  item jsonb;
  acc jsonb[] := array[]::jsonb[];
  BEGIN
    --RAISE NOTICE 'in with % and path %', json, path;
    IF json is NULL THEN
      --RAISE NOTICE 'ups';
      RETURN array[]::jsonb[];
    END IF;

    IF array_length(path, 1) IS NULL THEN
      -- expand array
      IF _is_array(json) THEN
        FOR item IN SELECT jsonb_array_elements(json)
        LOOP
          acc := acc || item;
        END LOOP;
        RETURN acc;
      ELSE
        RETURN array[json];
      END IF;
    END IF;

    IF _is_array(json) THEN
      FOR item IN SELECT jsonb_array_elements(json)
      LOOP
        acc := acc || json_get_in(item,path);
      END LOOP;
      RETURN acc;
    ELSIF _is_object(json) THEN
      RETURN json_get_in(json->path[1], _rest(path));
    ELSE
      RETURN array[]::jsonb[];
    END IF;

func jsonb_text_value(j jsonb) RETURNS varchar
  SELECT (json_build_object('x', j::json)->>'x')::varchar

proc json_array_to_str_array(_jsons jsonb[]) RETURNS varchar[]
  item jsonb;
  acc varchar[] := array[]::varchar[];
  BEGIN
    FOR item IN
      SELECT unnest(_jsons)
    LOOP
      acc := acc || (json_build_object('x', item)->>'x')::varchar;
    END LOOP;
    RETURN acc;

proc assert(_pred boolean, mess varchar) RETURNS varchar
  --- simple test fn
  item jsonb;
  acc varchar[] := array[]::varchar[];
  BEGIN
    IF _pred THEN
      RETURN 'OK ' || mess;
    ELSE
      RAISE EXCEPTION 'NOT OK %',  mess;
      RETURN 'not ok';
    END IF;

proc _debug(x anyelement) RETURNS anyelement
  BEGIN
    RAISE NOTICE 'DEBUG %', x;
    RETURN x;

proc assert_eq(expec anyelement, res anyelement, mess varchar) RETURNS varchar
  item jsonb;
  acc varchar[] := array[]::varchar[];
  BEGIN
    IF expec = res  OR (expec IS NULL AND res IS NULL) THEN
      RETURN 'OK ' || mess;
    ELSE
      RAISE EXCEPTION E'assert_eq % FAILED:\nEXPECTED: %\nACTUAL:   %', mess, expec, res;
      RETURN 'NOT OK';
    END IF;

proc expect(mess varchar, loc varchar, res anyelement, expec anyelement) RETURNS varchar
  item jsonb;
  acc varchar[] := array[]::varchar[];
  BEGIN
    IF expec = res  OR (expec IS NULL AND res IS NULL) THEN
      RETURN 'OK';
    ELSE
      RAISE INFO E'\tFAILED: % \n\tEXPECTED:\t%\n\tACTUAL:  \t%\n\tFILE: %', mess, expec, res, loc;
      RETURN 'NOT OK';
    END IF;

proc expect_raise(_err_ text, _loc_ text, _code_ varchar) RETURNS varchar
  BEGIN
    BEGIN
      EXECUTE _code_;
    EXCEPTION
      WHEN OTHERS THEN
        IF position(_err_ in SQLERRM) > 0 THEN
          RETURN 'OK; RAISE ' || _err_;
      ELSE
        RAISE INFO E'\tFAILED EXCEPTION: \n\tEXPECTED EXCEPTION: %\n\tACTUAL:   %\n\tFILE: %', _err_, SQLERRM, _loc_;
        RETURN 'NOT OK';
      END IF;
    END;
    RAISE INFO E'\tFAILED NO EXCEPTION: \n\tEXPECTED EXCEPTION: %\n\tBUT NO EXEPTION RAISED\n\tFILE: %', _err_, _loc_;
    RETURN 'NOT OK';

func _fhir_unescape_param(_str text) RETURNS text
  SELECT regexp_replace(_str, $RE$\\([,$|])$RE$, E'\\1', 'g')

func _fhir_spilt_to_table(_str text) RETURNS table (value text)
  SELECT _fhir_unescape_param(x)
   FROM regexp_split_to_table(regexp_replace(_str, $RE$([^\\]),$RE$, E'\\1,,,,,'), ',,,,,') x

func _merge_tags(_old_tags jsonb, _new_tags jsonb) RETURNS jsonb
 SELECT json_agg(x.x)::jsonb FROM (
   SELECT jsonb_array_elements(_new_tags) x
   UNION
   SELECT jsonb_array_elements(_old_tags) x
 ) x


DROP TABLE IF EXISTS __vars;
create table __vars ( name varchar primary key, value jsonb);

func! setv(_name_ text, _val_ jsonb) RETURNS text
  INSERT INTO __vars (name, value) VALUES (_name_, _val_)
    RETURNING name

func! getv(_name_ text) RETURNS jsonb
  SELECT value FROM __vars WHERE name = _name_

/* vim: ft=sql
*/
